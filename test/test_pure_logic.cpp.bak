#include <unity.h>
#include "time_logic.h"
#include <vector>
#include <ctime>

void setUp(void) {
    // テスト前の初期化
}

void tearDown(void) {
    // テスト後のクリーンアップ
}

// TimeLogic テスト
void test_time_validation() {
    // 正常な時刻
    TEST_ASSERT_TRUE(TimeLogic::isValidTime(12, 30));
    TEST_ASSERT_TRUE(TimeLogic::isValidTime(0, 0));
    TEST_ASSERT_TRUE(TimeLogic::isValidTime(23, 59));
    
    // 異常な時刻
    TEST_ASSERT_FALSE(TimeLogic::isValidTime(24, 0));
    TEST_ASSERT_FALSE(TimeLogic::isValidTime(12, 60));
    TEST_ASSERT_FALSE(TimeLogic::isValidTime(-1, 30));
    TEST_ASSERT_FALSE(TimeLogic::isValidTime(12, -1));
}

void test_relative_time_calculation() {
    time_t now = time(NULL);
    struct tm* tm_now = localtime(&now);
    
    // 現在時刻を基準にテスト
    int test_hour = tm_now->tm_hour;
    int test_min = tm_now->tm_min;
    
    // +1時間の計算
    time_t expected = now + 3600; // 1時間後
    time_t calculated = TimeLogic::calculateRelativeTime(test_hour, test_min, 1, 0, true);
    
    // 1分以内の誤差は許容
    TEST_ASSERT_INT_WITHIN(60, expected, calculated);
}

void test_absolute_time_calculation() {
    time_t calculated = TimeLogic::calculateAbsoluteTime(14, 30);
    
    struct tm tm_info;
    localtime_r(&calculated, &tm_info);
    
    TEST_ASSERT_EQUAL(14, tm_info.tm_hour);
    TEST_ASSERT_EQUAL(30, tm_info.tm_min);
    TEST_ASSERT_EQUAL(0, tm_info.tm_sec);
}

// AlarmLogic テスト
void test_alarm_duplicate_check() {
    std::vector<time_t> alarms;
    time_t test_time = time(NULL) + 3600; // 1時間後
    
    // 空のリスト
    TEST_ASSERT_FALSE(AlarmLogic::isDuplicateAlarm(alarms, test_time));
    
    // 同じ時刻を追加
    alarms.push_back(test_time);
    TEST_ASSERT_TRUE(AlarmLogic::isDuplicateAlarm(alarms, test_time));
    
    // 異なる時刻
    TEST_ASSERT_FALSE(AlarmLogic::isDuplicateAlarm(alarms, test_time + 1800)); // 30分後
}

void test_alarm_sorting() {
    std::vector<time_t> alarms;
    time_t now = time(NULL);
    
    // ランダムな順序でアラームを追加
    alarms.push_back(now + 7200); // 2時間後
    alarms.push_back(now + 3600); // 1時間後
    alarms.push_back(now + 10800); // 3時間後
    
    AlarmLogic::sortAlarms(alarms);
    
    // ソートされていることを確認
    TEST_ASSERT_TRUE(alarms[0] < alarms[1]);
    TEST_ASSERT_TRUE(alarms[1] < alarms[2]);
}

void test_max_alarm_limit() {
    std::vector<time_t> alarms;
    time_t now = time(NULL);
    
    // 5個のアラームを追加
    for (int i = 1; i <= 5; i++) {
        alarms.push_back(now + i * 3600);
    }
    
    TEST_ASSERT_EQUAL(5, alarms.size());
    
    // 6個目は追加できない
    TEST_ASSERT_FALSE(AlarmLogic::canAddAlarm(alarms));
}

void test_alarm_management() {
    std::vector<time_t> alarms;
    time_t now = time(NULL);
    time_t test_time = now + 3600;
    
    // アラーム追加
    TEST_ASSERT_TRUE(AlarmLogic::addAlarm(alarms, test_time));
    TEST_ASSERT_EQUAL(1, alarms.size());
    
    // 重複追加は失敗
    TEST_ASSERT_FALSE(AlarmLogic::addAlarm(alarms, test_time));
    TEST_ASSERT_EQUAL(1, alarms.size());
    
    // アラーム削除
    TEST_ASSERT_TRUE(AlarmLogic::removeAlarm(alarms, test_time));
    TEST_ASSERT_EQUAL(0, alarms.size());
}

// InputLogic テスト
void test_digit_increment() {
    int digit = 0;
    
    // 通常のインクリメント
    InputLogic::incrementDigit(digit, 9);
    TEST_ASSERT_EQUAL(1, digit);
    
    // 最大値でのインクリメント
    digit = 9;
    InputLogic::incrementDigit(digit, 9);
    TEST_ASSERT_EQUAL(0, digit);
    
    // 5ずつインクリメント
    digit = 0;
    InputLogic::incrementDigit(digit, 9, 5);
    TEST_ASSERT_EQUAL(5, digit);
}

void test_hour_validation() {
    // 時十の位の制約
    TEST_ASSERT_TRUE(InputLogic::isValidHourTens(1, 5));
    TEST_ASSERT_TRUE(InputLogic::isValidHourTens(2, 3));
    TEST_ASSERT_FALSE(InputLogic::isValidHourTens(2, 4));
    
    // 時一の位の制約
    TEST_ASSERT_TRUE(InputLogic::isValidHourOnes(1, 9));
    TEST_ASSERT_TRUE(InputLogic::isValidHourOnes(2, 3));
    TEST_ASSERT_FALSE(InputLogic::isValidHourOnes(2, 4));
}

void test_time_conversion() {
    int hour_tens, hour_ones, min_tens, min_ones;
    int hour, minute;
    
    // 時刻から入力値への変換
    InputLogic::timeToInput(14, 30, hour_tens, hour_ones, min_tens, min_ones);
    TEST_ASSERT_EQUAL(1, hour_tens);
    TEST_ASSERT_EQUAL(4, hour_ones);
    TEST_ASSERT_EQUAL(3, min_tens);
    TEST_ASSERT_EQUAL(0, min_ones);
    
    // 入力値から時刻への変換
    InputLogic::inputToTime(hour_tens, hour_ones, min_tens, min_ones, hour, minute);
    TEST_ASSERT_EQUAL(14, hour);
    TEST_ASSERT_EQUAL(30, minute);
}

void test_time_formatting() {
    time_t test_time = TimeLogic::calculateAbsoluteTime(9, 15);
    char buffer[10];
    
    TimeLogic::formatTimeString(test_time, buffer, sizeof(buffer));
    TEST_ASSERT_EQUAL_STRING("09:15", buffer);
}

int main() {
    UNITY_BEGIN();
    
    // TimeLogic テスト
    RUN_TEST(test_time_validation);
    RUN_TEST(test_relative_time_calculation);
    RUN_TEST(test_absolute_time_calculation);
    RUN_TEST(test_time_formatting);
    
    // AlarmLogic テスト
    RUN_TEST(test_alarm_duplicate_check);
    RUN_TEST(test_alarm_sorting);
    RUN_TEST(test_max_alarm_limit);
    RUN_TEST(test_alarm_management);
    
    // InputLogic テスト
    RUN_TEST(test_digit_increment);
    RUN_TEST(test_hour_validation);
    RUN_TEST(test_time_conversion);
    
    return UNITY_END();
} 