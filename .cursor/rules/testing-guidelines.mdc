# テストカバレッジ向上ガイドライン

## 概要
このガイドラインは、テストカバレッジを効率的に向上させるための手順を定義します。
目標は85%のカバレッジ達成です。

## 基本方針
1. **未カバーpublic関数を最優先**でテスト
2. **分岐カバレッジ**を重視
3. **段階的アプローチ**で効果を測定
4. **全体実行**によるカバレッジ測定

## 手順

### Step 1: 未カバーpublic関数の特定（最優先）
```bash
# 未カバー分岐を持つpublic関数を特定
grep -A 5 -B 5 '"count": 0' coverage_reports/coverage_report_*.json | grep -E '"function_name"|"line_number"' | head -20
```

**最優先対象**:
- `AlarmLogic`のpublic関数
- `AlarmDisplayState`のpublic関数
- `DateTimeInputState`のpublic関数

### Step 2: 未カバー分岐の特定
```bash
# 最新のカバレッジレポートから未カバー分岐を抽出
cat coverage_reports/coverage_report_*.json | jq '.files[] | select(.lines[] | .count == 0) | {file: .file, lines: [.lines[] | select(.count == 0)]}'
```

### Step 3: Public関数の未カバー分岐を優先
- 未カバー分岐がpublic関数にある場合、最優先でテスト追加
- private関数の未カバー分岐は後回し

### Step 4: 分岐カバレッジの効果を測定
```bash
# 全体テスト実行によるカバレッジ測定
python scripts/test_coverage.py --quick
```

### Step 5: 優先順位の決定
1. **最優先**: `AlarmLogic`のpublic関数
2. **高優先**: `AlarmDisplayState`のpublic関数
3. **中優先**: `DateTimeInputState`のpublic関数
4. **低優先**: その他のpublic関数

### Step 6: 段階的アプローチ
1. 1つのテストファイルに効果的なテストを追加
2. 全体テスト実行でカバレッジ測定
3. 効果があったら次の対象へ
4. 効果がなければ別のアプローチを検討

### Step 7: 効果判定と次の対象
- **効果あり**: カバレッジが0.1%以上向上
- **効果なし**: カバレッジ向上なし、または0.1%未満
- 効果があった場合は次の未カバー分岐へ
- 効果がない場合は別の関数やファイルを対象に変更

## 効果的なテスト例

### AlarmLogicのpublic関数テスト例
```cpp
// 未カバー分岐テスト: addAlarmの最大数チェック
void test_AlarmLogic_AddAlarm_MaxReached() {
    std::vector<time_t> alarms;
    time_t now = 1000;
    
    // 最大数までアラームを追加
    for (int i = 0; i < 5; i++) {
        AlarmLogic::AddAlarmResult result;
        std::string msg;
        bool ok = AlarmLogic::addAlarm(alarms, now, now + (i + 1) * 60, result, msg);
        TEST_ASSERT_TRUE(ok);
        TEST_ASSERT_EQUAL((int)AlarmLogic::AddAlarmResult::Success, (int)result);
    }
    
    // 6個目を追加しようとすると最大数エラー
    AlarmLogic::AddAlarmResult result;
    std::string msg;
    bool ok = AlarmLogic::addAlarm(alarms, now, now + 600, result, msg);
    TEST_ASSERT_FALSE(ok);
    TEST_ASSERT_EQUAL((int)AlarmLogic::AddAlarmResult::ErrorMaxReached, (int)result);
    TEST_ASSERT_EQUAL_STRING("Max alarms reached (5)", msg.c_str());
}
```

### AlarmDisplayStateのpublic関数テスト例
```cpp
// 未カバー分岐テスト: view == nullptrの場合のonDraw
void test_AlarmDisplayState_OnDraw_WithNullView() {
    MockStateManager mockManager;
    auto timeProvider = std::make_shared<MockTimeProvider>();
    auto timeManager = std::make_shared<MockTimeManager>();

    // viewをnullptrに設定
    AlarmDisplayState state(&mockManager, nullptr, timeProvider, timeManager);

    // onDrawを呼び出し（エラーが発生しないことを確認）
    state.onDraw();

    TEST_PASS();
}
```

## 効率的なカバレッジ確認方法

### 全体実行による測定
```bash
# 1. 現在のカバレッジ確認
python scripts/test_coverage.py --quick

# 2. テスト追加後、再度全体実行
python scripts/test_coverage.py --quick

# 3. 効果判定
# カバレッジが向上していれば効果あり
# 向上していなければ効果なし
```

### 進捗管理
```bash
# 進捗確認
echo "現在のカバレッジ: $(python scripts/test_coverage.py --quick | grep '純粋ロジックカバレッジ' | cut -d':' -f2 | tr -d ' ')"
echo "目標: 85.0%"
echo "残り: $(echo "85.0 - $(python scripts/test_coverage.py --quick | grep '純粋ロジックカバレッジ' | cut -d':' -f2 | tr -d ' ' | sed 's/%//')" | bc)%"
```

## 注意事項
- 個別ファイルのカバレッジ測定は複雑なため、全体実行を推奨
- 効果測定は必ず全体テスト実行で行う
- 0.1%以上の向上を効果ありと判定
- 効果がない場合は別のアプローチを検討
