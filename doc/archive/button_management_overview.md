# 統一されたボタン管理システム 全体概要

## プロジェクト概要

M5Stack Fire用集中タイマーにおけるボタン管理の分散とデバウンス処理の重複を解決し、将来的な拡張性（AB同時押しなど）に対応できる統一されたシステムを実装する。

## 現状の分析（2024年12月時点）

### 既に実装済みのコンポーネント
- ✅ **DebounceManager**: 階層化されたデバウンス管理システム
  - ハードウェアレベル（50ms）
  - 操作レベル（200ms）
  - 画面遷移レベル（300ms）
- ✅ **基本的なUIシステム**: Amber CRTテーマ、グリッドレイアウト
- ✅ **設定管理**: EEPROMベースの設定保存・読み込み
- ✅ **アラーム管理**: 基本的なアラーム機能

### 現在の問題点
- ❌ **ButtonManager未実装**: 統一されたボタン管理システムが存在しない
- ❌ **ボタン処理の分散**: `main.cpp`と`input.cpp`でボタン処理が重複
- ❌ **長押し/短押し判定の不統一**: 各画面で個別に実装
- ❌ **将来拡張への対応困難**: AB同時押し、ABC同時押しの実装が困難

## 設計方針

### 1. 階層化されたデバウンス管理（既存のDebounceManagerを活用）
```
┌─────────────────────────────────────┐
│ 画面遷移レベル (ModeManager)         │
│ - モード切り替えの安定性            │
│ - デバウンス時間: 300ms             │
├─────────────────────────────────────┤
│ 操作レベル (各画面)                  │
│ - 意図しない操作の防止              │
│ - デバウンス時間: 200ms             │
├─────────────────────────────────────┤
│ ハードウェアレベル (ButtonManager)   │
│ - 物理的なチャタリング対策          │
│ - デバウンス時間: 50ms              │
└─────────────────────────────────────┘
```

### 2. 統一されたボタン管理システム（新規実装）
```
┌─────────────────────────────────────┐
│ ButtonManager (一元管理)             │
│ ├─ 基本的な判定                      │
│ │  ├─ isShortPress()                │
│ │  ├─ isLongPress()                 │
│ │  └─ isReleased()                  │
│ ├─ 同時押し判定                      │
│ │  ├─ isSimultaneousPress()         │
│ │  ├─ isAllButtonsPressed()         │
│ │  └─ isCombinationPress()          │
│ └─ 拡張性のための基盤                │
│   ├─ ボタン状態の履歴管理            │
│   ├─ イベントシステム                │
│   └─ プラグイン可能な判定機能        │
└─────────────────────────────────────┘
```

## 実装戦略

### 段階的実装の原則
1. **各ステップでコンパイルが通る状態を維持**
2. **既存機能を壊さずに段階的に移行**
3. **動作確認しながら進める**
4. **必要に応じてロールバック可能**
5. **既存のDebounceManagerを活用**

### 実装順序
```
Phase 1: ButtonManagerクラスの実装（既存コードは変更なし）
Phase 2: 既存コードにButtonManagerを並行導入
Phase 3: 段階的に既存コードをButtonManagerに移行
Phase 4: 完全移行と最適化
Phase 5: 同時押し機能の実装
```

## 各Phaseの詳細

### Phase 1: ButtonManagerクラスの実装
- **目的**: 統一されたボタン管理システムの基盤構築
- **詳細**: [Phase 1 詳細仕様](./button_management_phase1.md)
- **成果物**: ButtonManagerクラス、基本的なテスト

### Phase 2: 並行導入
- **目的**: 既存コードを壊さずにButtonManagerを導入
- **詳細**: [Phase 2 詳細仕様](./button_management_phase2.md)
- **成果物**: 並行動作するシステム、統合テスト

### Phase 3: 段階的移行
- **目的**: 既存コードを少しずつButtonManagerに移行
- **詳細**: [Phase 3 詳細仕様](./button_management_phase3.md)
- **成果物**: 部分移行されたシステム、段階的テスト

### Phase 4: 完全移行と最適化
- **目的**: 完全移行と新機能の実装
- **詳細**: [Phase 4 詳細仕様](./button_management_phase4.md)
- **成果物**: 完全移行されたシステム、警告メッセージ機能

### Phase 5: 同時押し機能
- **目的**: 将来拡張への対応
- **詳細**: [Phase 5 詳細仕様](./button_management_phase5.md)
- **成果物**: 同時押し機能、高度なテスト

## 期待される効果

### 1. 保守性の向上
- ボタン処理ロジックの一元化
- デバウンス処理の統一（既存のDebounceManagerを活用）
- コードの重複削除
- 既存コードとの整合性維持

### 2. 拡張性の向上
- 新しいボタン操作パターンの簡単追加
- 同時押し機能への対応
- 将来的な機能拡張への対応
- 既存のDebounceManagerとの連携

### 3. デバッグ性の向上
- ボタン操作の履歴管理
- デバウンス処理の可視化
- 問題の特定と解決の容易化
- 既存のテスト環境との統合

### 4. ユーザビリティの向上
- より直感的なボタン操作
- 意図しない操作の防止
- 一貫した操作感
- 警告メッセージによるユーザーフィードバック

## 成功指標

### 技術的指標
- コンパイルエラー0件
- 既存機能の動作確認100%
- 新機能のテストカバレッジ80%以上
- メモリ使用量の増加20%以下

### 品質指標
- ボタン操作の応答性維持
- デバウンス処理の効果確認
- ユーザビリティの向上
- コードの保守性向上

### 開発効率指標
- 段階的実装の成功
- テスト環境の活用
- 既存コードとの整合性維持
- 将来拡張への対応準備

## リスクと対策

### 1. 既存機能への影響
**リスク**: リファクタリングによる既存機能の破綻
**対策**: 段階的な移行と十分なテスト、既存のDebounceManagerを活用

### 2. パフォーマンスへの影響
**リスク**: 新しいシステムによる処理負荷の増加
**対策**: 最適化とプロファイリング、既存のデバウンス処理を活用

### 3. メモリ使用量の増加
**リスク**: 新しいクラスによるメモリ消費の増加
**対策**: メモリ効率の良い実装、既存のメモリ管理との統合

### 4. 既存コードとの整合性
**リスク**: 既存のDebounceManagerとの不整合
**対策**: 既存のDebounceManagerを活用し、拡張する形で実装

## 次のステップ

1. **Phase 1の開始**: ButtonManagerクラスの基本実装
2. **既存コードの分析**: 移行対象の特定と順序決定
3. **テスト計画の策定**: 各Phaseでのテスト項目定義

各Phaseの詳細仕様を参照して、段階的に実装を進めてください。 