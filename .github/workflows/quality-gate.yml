name: Quality Gate

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled]
  pull_request_review:
    types: [submitted]
  workflow_dispatch:

# 自動マージで必要な権限（PR/ブランチ操作）
permissions:
  contents: write
  pull-requests: write

# 同一PRの重複実行を抑止
concurrency:
  group: quality-gate-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  quality-gate:
    # draft PR はスキップ
    if: ${{ !github.event.pull_request.draft }}
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies (pip)
        run: |
          python -m pip install --upgrade pip
          pip install platformio gcovr

      - name: Install clang-tidy (ubuntu)
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-tidy build-essential

      - name: Baseline build (sanity)
        run: pio run -e native

      - name: Print tool versions / PWD / key files
        run: |
          pwd
          ls -la
          platformio --version || true
          pio --version || true
          clang-tidy --version || true
          python --version
          test -f platformio.ini && echo "[ok] platformio.ini found" || echo "[ng] platformio.ini not found"
          test -f .clang-tidy && echo "[ok] .clang-tidy found" || echo "[ng] .clang-tidy not found"

      - name: Cleanup stale analysis outputs
        run: |
          rm -f static_analysis_report.json static_analysis_raw.json static_analysis_raw.txt pio_project_config.json || true

      - name: Run pio check (capture raw JSON and text)
        run: |
          set -e
          pio check -e native --json-output > static_analysis_raw.json || true
          pio check -e native > static_analysis_raw.txt || true
          echo "JSON_BYTES=$(wc -c < static_analysis_raw.json 2>/dev/null || echo 0)" >> $GITHUB_ENV

      - name: Dump pio project config
        run: |
          pio project config --json > pio_project_config.json || true

      - name: Run quality gate
        run: |
          python scripts/quality_gate.py

      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quality-gate-artifacts-${{ github.run_id }}
          path: |
            coverage_reports/**
            coverage_history.json
            static_analysis_report.json
            static_analysis_raw.json
            static_analysis_raw.txt
            pio_project_config.json
          if-no-files-found: warn

      - name: Job summary
        if: always()
        shell: bash
        run: |
          echo "## Quality Gate" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- Workflow: $GITHUB_WORKFLOW" >> "$GITHUB_STEP_SUMMARY"
          echo "- Run ID: $GITHUB_RUN_ID" >> "$GITHUB_STEP_SUMMARY"
          echo "- Artifacts: quality-gate-artifacts-$GITHUB_RUN_ID" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          echo "### pio check (raw capture)" >> "$GITHUB_STEP_SUMMARY"
          echo "- JSON bytes: ${JSON_BYTES:-0}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Raw text tail:" >> "$GITHUB_STEP_SUMMARY"
          (tail -n 20 static_analysis_raw.txt 2>/dev/null | sed 's/^/  /') >> "$GITHUB_STEP_SUMMARY" || true


      - name: Job summary (coverage)
        if: always()
        shell: python
        run: |
          import json, os
          outp = os.environ.get('GITHUB_STEP_SUMMARY')
          cov = None
          # Prefer latest coverage summary if exists
          p1 = 'coverage_reports/coverage_summary.json'
          if os.path.exists(p1):
              try:
                  with open(p1, encoding='utf-8') as f:
                      d = json.load(f)
                  cov = d.get('overall',{}).get('coverage_percentage') or d.get('coverage_percentage')
              except Exception:
                  pass
          # Fallback to history
          if cov is None and os.path.exists('coverage_history.json'):
              try:
                  with open('coverage_history.json', encoding='utf-8') as f:
                      txt = f.read()
                  import re
                  m = list(re.finditer(r'"coverage"\s*:\s*([0-9.]+)', txt))
                  if m:
                      cov = m[-1].group(1)
              except Exception:
                  pass
          # Threshold for display
          thr = None
          strict = False
          if os.path.exists('coverage_config.json'):
              try:
                  with open('coverage_config.json', encoding='utf-8') as f:
                      cfg = json.load(f)
                  thr = cfg.get('quality_gate',{}).get('threshold')
                  strict = bool(cfg.get('quality_gate',{}).get('strict_mode'))
                  if strict:
                      thr = 85.0
              except Exception:
                  pass
          if outp:
              with open(outp,'a',encoding='utf-8') as g:
                  g.write("\n### Coverage\n")
                  if cov is not None:
                      g.write(f"- Actual: {cov}%\n")
                  else:
                      g.write("- Actual: (see artifacts)\n")
                  if thr is not None:
                      g.write(f"- Threshold: {thr}%{' (strict)' if strict else ''}\n")
                      # 判定表示（グリーン/レッド）
                      try:
                          cov_val = float(cov)
                          thr_val = float(thr)
                          passed = cov_val >= thr_val
                          g.write(f"- Status: {'✅ Passed' if passed else '❌ Failed'}\n")
                      except Exception:
                          g.write("- Status: (判定不可)\n")

      - name: Job summary (static analysis)
        if: always()
        shell: python
        run: |
          import json, os
          p = 'static_analysis_report.json'
          s = os.environ.get('GITHUB_STEP_SUMMARY')
          if s and os.path.exists(p):
              with open(p, encoding='utf-8') as f:
                  d = json.load(f)
              t = d.get('totals', {})
              th = d.get('thresholds', {})
              passed = d.get('passed', False)
              with open(s, 'a', encoding='utf-8') as g:
                  g.write("\n### Static Analysis (Clang-Tidy)\n")
                  g.write(f"- Environment: {d.get('environment','native')}\n")
                  g.write(f"- Totals: High={t.get('high',0)}, Medium={t.get('medium',0)}, Low={t.get('low',0)}\n")
                  g.write(f"- Thresholds: High={th.get('high','-')}, Medium={th.get('medium','-')}, Low={th.get('low','-')}\n")
                  g.write(f"- Status: {'✅ Passed' if passed else '❌ Failed'}\n")


  automerge:
    name: Auto-merge when CI passed and hw-ok or approved
    needs: quality-gate
    runs-on: ubuntu-latest
    if: >
      ${{
        (github.event_name == 'pull_request' || github.event_name == 'pull_request_review') &&
        !github.event.pull_request.draft
      }}
    steps:
      - name: Merge (and delete branch on success)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            if (!pr || pr.state !== 'open') { return; }

            // 条件: hw-ok ラベル or 承認
            const hasHwOk = Array.isArray(pr.labels) && pr.labels.some(l => l && l.name === 'hw-ok');
            let isApproved = false;
            try {
              const reviews = await github.rest.pulls.listReviews({ owner, repo, pull_number: pr.number });
              isApproved = (reviews.data || []).some(r => r && r.state === 'APPROVED');
            } catch (e) {
              core.warning(`listReviews failed: ${e.message}`);
            }
            if (!hasHwOk && !isApproved) {
              core.info('Skip: need hw-ok label or at least one approval');
              return;
            }

            // マージ実行
            let merged = false;
            try {
              const res = await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: 'squash' });
              merged = !!(res && res.data && res.data.merged);
              core.info(`merge result: ${merged}`);
            } catch (e) {
              core.warning(`Merge failed: ${e.message}`);
            }

            // 成功時のみブランチ削除（同一リポジトリに限る）
            if (merged) {
              const sameRepo = pr.head && pr.head.repo && (pr.head.repo.full_name === `${owner}/${repo}`);
              if (sameRepo) {
                const ref = 'heads/' + pr.head.ref;
                try {
                  await github.rest.git.deleteRef({ owner, repo, ref });
                  core.info(`Deleted branch ${ref}`);
                } catch (e) {
                  core.warning(`Delete branch skipped: ${e.message}`);
                }
              }
            }
