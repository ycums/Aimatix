name: Quality Gate

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled]
  pull_request_review:
    types: [submitted]
  workflow_dispatch:

# 自動マージで必要な権限（PR/ブランチ操作）
permissions:
  contents: write
  pull-requests: write

# 同一PRの重複実行を抑止
concurrency:
  group: quality-gate-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  quality-gate:
    # draft PR はスキップ
    if: ${{ !github.event.pull_request.draft }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      docs_only: ${{ steps.docs_only.outputs.value }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Paths filter
        id: paths
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          filters: |
            docs:
              - 'doc/**'
              - '**/*.md'
              - '**/*.mdc'
            code:
              - 'lib/libaimatix/**'
              - 'src/**'
              - 'test/**'
              - 'scripts/**'
              - 'platformio.ini'
              - '.github/workflows/**'

      - name: Compute docs_only
        id: docs_only
        shell: bash
        run: |
          DOCS="${{ steps.paths.outputs.docs }}"
          CODE="${{ steps.paths.outputs.code }}"
          if [ "$DOCS" = "true" ] && [ "$CODE" != "true" ]; then
            echo "value=true" >> "$GITHUB_OUTPUT"
          else
            echo "value=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies (pip)
        run: |
          python -m pip install --upgrade pip
          pip install platformio gcovr

      - name: Install clang-tidy (ubuntu)
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-tidy build-essential

      - name: Baseline build (sanity)
        run: pio run -e native

      - name: Run quality gate
        run: |
          python scripts/quality_gate.py

      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quality-gate-artifacts-${{ github.run_id }}
          path: |
            coverage_reports/**
            coverage_history.json
            static_analysis_report.json
            static_analysis_raw.txt
          if-no-files-found: warn

      - name: Job summary
        if: always()
        shell: bash
        run: |
          echo "## Quality Gate" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- Workflow: $GITHUB_WORKFLOW" >> "$GITHUB_STEP_SUMMARY"
          echo "- Run ID: $GITHUB_RUN_ID" >> "$GITHUB_STEP_SUMMARY"
          echo "- Artifacts: quality-gate-artifacts-$GITHUB_RUN_ID" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"


      - name: Job summary (coverage)
        if: always()
        shell: python
        run: |
          import json, os, re
          outp = os.environ.get('GITHUB_STEP_SUMMARY')
          cov = None
          # Use coverage_history.json as the sole source
          if os.path.exists('coverage_history.json'):
              try:
                  with open('coverage_history.json', encoding='utf-8') as f:
                      txt = f.read()
                  m = list(re.finditer(r'"coverage"\s*:\s*([0-9.]+)', txt))
                  if m:
                      cov = m[-1].group(1)
              except Exception:
                  pass
          # Threshold for display (values are defined in coverage_config.json)
          thr = None
          strict = False
          if os.path.exists('coverage_config.json'):
              try:
                  with open('coverage_config.json', encoding='utf-8') as f:
                      cfg = json.load(f)
                  qg = cfg.get('quality_gate',{}) or {}
                  thr = qg.get('threshold')
                  strict = bool(qg.get('strict_mode'))
              except Exception:
                  pass
          if outp:
              with open(outp,'a',encoding='utf-8') as g:
                  g.write("\n### Coverage\n")
                  if cov is not None:
                      g.write(f"- Actual: {cov}%\n")
                  else:
                      g.write("- Actual: (see artifacts)\n")
                  if thr is not None:
                      g.write(f"- Threshold: {thr}%{' (strict)' if strict else ''}\n")
                      try:
                          cov_val = float(cov) if cov is not None else None
                          thr_val = float(thr)
                          passed = (cov_val is not None) and (cov_val >= thr_val)
                          g.write(f"- Status: {'✅ Passed' if passed else '❌ Failed'}\n")
                      except Exception:
                          g.write("- Status: (判定不可)\n")

      - name: Job summary (static analysis)
        if: always()
        shell: python
        run: |
          import json, os
          p = 'static_analysis_report.json'
          s = os.environ.get('GITHUB_STEP_SUMMARY')
          if s and os.path.exists(p):
              with open(p, encoding='utf-8') as f:
                  d = json.load(f)
              t = d.get('totals', {})
              th = d.get('thresholds', {})
              passed = d.get('passed', False)
              with open(s, 'a', encoding='utf-8') as g:
                  g.write("\n### Static Analysis (Clang-Tidy)\n")
                  g.write(f"- Environment: {d.get('environment','native')}\n")
                  g.write(f"- Totals: High={t.get('high',0)}, Medium={t.get('medium',0)}, Low={t.get('low',0)}\n")
                  g.write(f"- Thresholds: High={th.get('high','-')}, Medium={th.get('medium','-')}, Low={th.get('low','-')}\n")
                  g.write(f"- Status: {'✅ Passed' if passed else '❌ Failed'}\n")


  automerge:
    name: Auto-merge when CI passed and hw-ok or approved
    needs: quality-gate
    runs-on: ubuntu-latest
    if: >
      ${{
        (github.event_name == 'pull_request' || github.event_name == 'pull_request_review') &&
        !github.event.pull_request.draft &&
        needs.quality-gate.result == 'success'
      }}
    steps:
      - name: Merge (and delete branch on success)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          env:
            DOCS_ONLY: ${{ needs.quality-gate.outputs.docs_only }}
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            if (!pr || pr.state !== 'open') { return; }

            // ラベル検出
            const hasHwOk = Array.isArray(pr.labels) && pr.labels.some(l => l && l.name === 'hw-ok');
            const hasNoHw = Array.isArray(pr.labels) && pr.labels.some(l => l && l.name === 'no-hw');
            const hasAutomerge = Array.isArray(pr.labels) && pr.labels.some(l => l && l.name === 'automerge');
            let isApproved = false;
            try {
              const reviews = await github.rest.pulls.listReviews({ owner, repo, pull_number: pr.number });
              isApproved = (reviews.data || []).some(r => r && r.state === 'APPROVED');
            } catch (e) {
              core.warning(`listReviews failed: ${e.message}`);
            }

            const docsOnly = String(process.env.DOCS_ONLY).trim() === 'true';
            let canMerge = false;
            if (docsOnly) {
              // docsのみ変更: no-hw + automerge が付与されている場合に自動マージ
              canMerge = hasNoHw && hasAutomerge;
              if (!canMerge) {
                core.info('Skip: docs-only PR requires both no-hw and automerge labels');
              }
            } else {
              // 従来条件: hw-ok ラベル or 承認
              canMerge = hasHwOk || isApproved;
              if (!canMerge) {
                core.info('Skip: need hw-ok label or at least one approval');
              }
            }
            if (!canMerge) { return; }

            // マージ実行
            let merged = false;
            try {
              const res = await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: 'squash' });
              merged = !!(res && res.data && res.data.merged);
              core.info(`merge result: ${merged}`);
            } catch (e) {
              core.warning(`Merge failed: ${e.message}`);
            }

            // 成功時のみブランチ削除（同一リポジトリに限る）
            if (merged) {
              const sameRepo = pr.head && pr.head.repo && (pr.head.repo.full_name === `${owner}/${repo}`);
              if (sameRepo) {
                const ref = 'heads/' + pr.head.ref;
                try {
                  await github.rest.git.deleteRef({ owner, repo, ref });
                  core.info(`Deleted branch ${ref}`);
                } catch (e) {
                  core.warning(`Delete branch skipped: ${e.message}`);
                }
              }
            }
